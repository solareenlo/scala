'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/scala/','title':"Scala",'content':"Scala 特徴  オブジェクト指向プログラミングと関数型プログラミングの両方ができる特徴を持ったプログラミング言語． 非同期プログラミング，並行・並列処理を得意とする． Java Virtual Machine (JVM) 上で動く． 2003 年に スイス連邦工科大学の Martin Odersky 教授によって開発されたプログラミング言語． GitHub: scala/scala WebSite: https://scala-lang.org  解説ページ   日本の Scala コミュニティによる解説ページ  N 予備校による解説ページ  "});index.add({'id':1,'href':'/sbt/','title':"sbt",'content':"sbt 概要  Scala の標準的なビルドツール． GitHub: sbt/sbt WebSite: https://www.scala-sbt.org/ Docs-en: https://www.scala-sbt.org/1.x/docs/ Docs-ja: https://www.scala-sbt.org/release/docs/ja/index.html  Docker で使う  GitHub: hseeberger/scala-sbt GitHub: mozilla/docker-sbt  image を build する docker build \\  --build-arg BASE_IMAGE_TAG=\u0026#34;8u212-b04-jdk-stretch\u0026#34; \\  --build-arg SBT_VERSION=\u0026#34;1.3.8\u0026#34; \\  --build-arg SCALA_VERSION=\u0026#34;2.13.1\u0026#34; \\  --build-arg USER_ID=1001 \\  --build-arg GROUP_ID=1001 \\  -t solareenlo/scala-sbt \\  github.com/hseeberger/scala-sbt.git#:debian docker run # コンテナを走らせる sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest bash sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest scala sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest sbt 使い方 sbt runMain TestStudy or\nsbt run or\nsbt console 設定ファイル touch build.sbt # build.sbt scalaVersion := \u0026#34;2.13.1\u0026#34; scalacOptions ++= Seq(\u0026#34;-deprecation\u0026#34;, \u0026#34;-feature\u0026#34;, \u0026#34;-unchecked\u0026#34;, \u0026#34;-Xlint\u0026#34;) 上記のオプションを付けることで以下の警告の情報を出してくれるようになる．\n -deprecation: 今後廃止の予定のAPIを利用している -feature: 明示的に使用を宣言しないといけない実験的な機能や注意しなければならない機能を利用している -unchecked: 型消去などでパターンマッチが有効に機能しない場合 -Xlint: その他，望ましい書き方や落とし穴についての情報  "});index.add({'id':2,'href':'/scala/02_class/','title':"class",'content':"class  scala における class とは，object を作るための設計図のこと． class はメソッド，値，変数，型，object，trait，class を持つ．  記法  ` ` \u0026hellip; アルファベットや記号の並び ( ) \u0026hellip; グルーピング \u0026lt; \u0026gt; \u0026hellip; 何らかの構文要素 * \u0026hellip; その要素が0回以上現れる + \u0026hellip; その要素が1回以上現れる ? \u0026hellip; その要素が0回または1回現れる A | B \u0026hellip; A と B のどちらでも良い ... \u0026hellip; 同じパターンで出現する  定義 クラス定義 class \u0026lt;クラス名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名1\u0026gt; : \u0026lt;引数型1\u0026gt;, \u0026lt;引数名2\u0026gt;: \u0026lt;引数型2\u0026gt; ...)? \u0026#39;)\u0026#39; { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt; )* } メソッド定義 メソッド： class や object 内の操作のこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; = \u0026lt;本体\u0026gt; or ブロック式を使ったメソッド\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; = { (\u0026lt;式\u0026gt; (; | \u0026lt;改行\u0026gt;)?)* } or 複数の引数メソッドを持つメソッド\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;( \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39; )* : \u0026lt;返り値型\u0026gt; = \u0026lt;本体式\u0026gt; フィールド定義 フィールド： class や object 内の変数や定数や値のこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? (val | var) \u0026lt;フィールド名\u0026gt;: \u0026lt;フィールド型\u0026gt; = \u0026lt;初期化式\u0026gt; 抽象メンバー定義 メンバー： フィールドやメソッドのこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; 継承定義 class \u0026lt;クラス名\u0026gt; \u0026lt;クラス引数\u0026gt; (extends \u0026lt;スーパークラス\u0026gt;)? (with \u0026lt;トレイト名\u0026gt;)* { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } "});index.add({'id':3,'href':'/scala/03_object/','title':"object",'content':"object  scala では1つのインスタンスを持つ class のこと． 別の言い方をすると，object で宣言された class からは，1つのインスタンスしか生成することができない． これをシングルトンオブジェクトという．  定義 object \u0026lt;オブジェクト名\u0026gt; extends \u0026lt;クラス名\u0026gt; (with \u0026lt;トレイト名\u0026gt;)* { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } コンパニオンオブジェクト  class と同じファイル内，同じ名前で定義されたシングルトンオブジェクトのこと． コンパニオンオブジェクトは対応する class に対して特権的なアクセス権を有している．  class 内の privete にアクセスできる． class 内の privete[this] にはアクセスできない．    "});index.add({'id':4,'href':'/scala/04_trait/','title':"trait",'content':"trait  scala のオブジェクト指向プログラミングにおけるモジュール化の中心的な概念． class に近い機能を持ちながら実質的な多重継承が可能．  定義 trait \u0026lt;トレイト名\u0026gt; { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } 主な特徴  複数の trait を1つの class や trait に mixin できる． 直接インスタンス化できない．  これは trait が単体で使われることを想定しないため．   クラスパラメータ（コンストラクタの引数）を取ることができない．  trait に抽象メンバーを持たせることで値を渡すことができる． trait を class に継承させたり，インスタンス化のときに抽象メンバーを実装することで trait に値を渡すことができる．    "});})();