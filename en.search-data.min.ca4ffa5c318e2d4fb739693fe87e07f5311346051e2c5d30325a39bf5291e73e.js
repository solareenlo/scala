'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/scala/','title':"Scala",'content':"Scala 特徴  オブジェクト指向プログラミングと関数型プログラミングの両方ができる特徴を持ったプログラミング言語． 非同期プログラミング，並行・並列処理を得意とする． Java Virtual Machine (JVM) 上で動く． 2003 年に スイス連邦工科大学の Martin Odersky 教授によって開発されたプログラミング言語． GitHub: scala/scala WebSite: https://scala-lang.org  おすすめの勉強する順番   N 予備校による解説ページ  日本の Scala コミュニティによる解説ページ  S-99: Ninety-Nine Scala Problems を解いてみる． コップ本を読んでみる．  解説ページ   公式ドキュメント  日本の Scala コミュニティによる解説ページ  N 予備校による解説ページ  Scala の省略ルール早覚え  Scala入門時に役立つ情報まとめ  "});index.add({'id':1,'href':'/docs/scala/sbt/','title':"sbt",'content':"sbt 概要  Scala の標準的なビルドツール． GitHub: sbt/sbt WebSite: https://www.scala-sbt.org/ Docs-en: https://www.scala-sbt.org/1.x/docs/ Docs-ja: https://www.scala-sbt.org/release/docs/ja/index.html  Docker で使う  GitHub: hseeberger/scala-sbt GitHub: mozilla/docker-sbt  image を build する docker build \\  --build-arg BASE_IMAGE_TAG=\u0026#34;8u212-b04-jdk-stretch\u0026#34; \\  --build-arg SBT_VERSION=\u0026#34;1.3.8\u0026#34; \\  --build-arg SCALA_VERSION=\u0026#34;2.13.1\u0026#34; \\  --build-arg USER_ID=1001 \\  --build-arg GROUP_ID=1001 \\  -t solareenlo/scala-sbt \\  github.com/hseeberger/scala-sbt.git#:debian docker run # コンテナを走らせる sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest bash sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest scala sudo docker run -it --rm -v $(pwd):/root solareenlo/scala-sbt:latest sbt 使い方 sbt runMain TestStudy or\nsbt run or\nsbt console 設定ファイル touch build.sbt # build.sbt scalaVersion := \u0026#34;2.13.1\u0026#34; scalacOptions ++= Seq(\u0026#34;-deprecation\u0026#34;, \u0026#34;-feature\u0026#34;, \u0026#34;-unchecked\u0026#34;, \u0026#34;-Xlint\u0026#34;) 上記のオプションを付けることで以下の警告の情報を出してくれるようになる．\n -deprecation: 今後廃止の予定のAPIを利用している -feature: 明示的に使用を宣言しないといけない実験的な機能や注意しなければならない機能を利用している -unchecked: 型消去などでパターンマッチが有効に機能しない場合 -Xlint: その他，望ましい書き方や落とし穴についての情報  "});index.add({'id':2,'href':'/docs/scala/class/','title':"class",'content':"class  scala における class とは，object を作るための設計図のこと． class はメソッド，値，変数，型，object，trait，class を持つ．  記法  ` ` \u0026hellip; アルファベットや記号の並び ( ) \u0026hellip; グルーピング \u0026lt; \u0026gt; \u0026hellip; 何らかの構文要素 * \u0026hellip; その要素が0回以上現れる + \u0026hellip; その要素が1回以上現れる ? \u0026hellip; その要素が0回または1回現れる A | B \u0026hellip; A と B のどちらでも良い ... \u0026hellip; 同じパターンで出現する  定義 クラス定義 class \u0026lt;クラス名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名1\u0026gt; : \u0026lt;引数型1\u0026gt;, \u0026lt;引数名2\u0026gt;: \u0026lt;引数型2\u0026gt; ...)? \u0026#39;)\u0026#39; { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt; )* } メソッド定義 メソッド： class や object 内の操作のこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; = \u0026lt;本体\u0026gt; or ブロック式を使ったメソッド\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; = { (\u0026lt;式\u0026gt; (; | \u0026lt;改行\u0026gt;)?)* } or 複数の引数メソッドを持つメソッド\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;( \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39; )* : \u0026lt;返り値型\u0026gt; = \u0026lt;本体式\u0026gt; フィールド定義 フィールド： class や object 内の変数や定数や値のこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? (val | var) \u0026lt;フィールド名\u0026gt;: \u0026lt;フィールド型\u0026gt; = \u0026lt;初期化式\u0026gt; 抽象メンバー定義 メンバー： フィールドやメソッドのこと．\n(private([this | \u0026lt;パッケージ名\u0026gt;])? | protected([\u0026lt;パッケージ名\u0026gt;])?)? def \u0026lt;メソッド名\u0026gt; \u0026#39;(\u0026#39; (\u0026lt;引数名\u0026gt; : 引数型 (, 引数名 : \u0026lt;引数型\u0026gt;)*)? \u0026#39;)\u0026#39;: \u0026lt;返り値型\u0026gt; 継承定義 class \u0026lt;クラス名\u0026gt; \u0026lt;クラス引数\u0026gt; (extends \u0026lt;スーパークラス\u0026gt;)? (with \u0026lt;トレイト名\u0026gt;)* { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } "});index.add({'id':3,'href':'/docs/scala/object/','title':"object",'content':"object  scala では1つのインスタンスを持つ class のこと． 別の言い方をすると，object で宣言された class からは，1つのインスタンスしか生成することができない． これをシングルトンオブジェクトという．  定義 object \u0026lt;オブジェクト名\u0026gt; extends \u0026lt;クラス名\u0026gt; (with \u0026lt;トレイト名\u0026gt;)* { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } コンパニオンオブジェクト  class と同じファイル内，同じ名前で定義されたシングルトンオブジェクトのこと． コンパニオンオブジェクトは対応する class に対して特権的なアクセス権を有している．  class 内の privete にアクセスできる． class 内の privete[this] にはアクセスできない．    "});index.add({'id':4,'href':'/docs/scala/trait/','title':"trait",'content':"trait  scala のオブジェクト指向プログラミングにおけるモジュール化の中心的な概念． class に近い機能を持ちながら実質的な多重継承が可能．  定義 trait \u0026lt;トレイト名\u0026gt; { (\u0026lt;フィールド定義\u0026gt; | \u0026lt;メソッド定義\u0026gt;)* } 主な特徴  複数の trait を1つの class や trait に mixin できる． 直接インスタンス化できない．  これは trait が単体で使われることを想定しないため．   クラスパラメータ（コンストラクタの引数）を取ることができない．  trait に抽象メンバーを持たせることで値を渡すことができる． trait を class に継承させたり，インスタンス化のときに抽象メンバーを実装することで trait に値を渡すことができる．    "});index.add({'id':5,'href':'/docs/scala/type-parameter/','title':"type parameter",'content':"型パラメータ（type parameter）  class を作る時点では何の type か特定できない場合に用いる． どの type でも同じ処理を抽象化できる．  定義 class \u0026lt;クラス名\u0026gt;[\u0026lt;型パラメータ1\u0026gt;, \u0026lt;型パラメータ2\u0026gt;, ...](\u0026lt;クラス引数\u0026gt;) { (\u0026lt;フィールド定義\u0026gt;|\u0026lt;メソッド定義\u0026gt;)* } Tuple1 ~ Tuple22  Tuple1 ~ Tuple22 （数字は要素数）とは，複数の引数を操作するあらかじめ用意された便利なクラスのこと．  val m = 7 val n = 3 // 下の2つは同じこと new Tuple2(m / n, m % n) (m / n, m % n) // (Int, Int) = (2, 1) 変位指定（variance） 非変（invariant）  Scala は基本的に型パラーメータは非変（invariant）． 下記の場合に A と B の型が一致していないといけない．  val: G[A] = G[B] 共変（covariant） class G[+A] val: G[B] = G[A]  A は B を継承していないといけない．  反変（contravariant） class G[-A] val: G[A] = G[B]  A は B を継承していないといけない． わかりやすい例は関数の型．  関数の引数の型は戻り値の型を継承していなくてはならない．    型パラメータの境界（bounds） 上限境界（upper bounds）  自分がどのような型を継承しているかを指定するもの． 対象の型（自分）を別の型のサブタイプに制限するもの． 自分 \u0026lt;: 上限の型  下限境界（lower bounds）  自分がどのような型のスーパータイプであるかを指定するもの． 対象の型（自分）が別の型のスーパータイプであることを宣言するもの． 下限の型 \u0026gt;: 自分  "});index.add({'id':6,'href':'/docs/scala/function/','title':"function",'content':"関数  Scala の関数は単に，Function0 ~ Function22 までのトレイトの無名サブクラスのインスタンスを作っているだけ．  よって，引数の最大個数は22個である．   Function0 ~ Function22 までの全ての関数は引数の数に応じた apply メソッドを定義する必要がある． apply メソッドは Scala のコンパイラから特別扱いされ，x.apply(y) は x(y) のように書くことができる． Scala では Function0 ~ Function22 までのトレイトのインスタンスを生成するためのシンタックスシュガーが用意されている．  // 下の2つは同じ扱いになる val add = new Function2[Int, Int, Int] { def apply(x: Int, y: Int): Int = x + y } val add = (x: Int, y: Int) =\u0026gt; x + y // 上のシンタックスシュガー  // 下の2つは同じこと add.apply(10, 20) add.(10, 20) 無名関数  無名関数とは，関数の中に関数オブジェクトだけが入っている関数のこと． よって，無名関数は単なる FunctionN オブジェクトになる． よって，無名関数を自由に変数や引数に代入したり返り値として返したりできる． このように，関数を自由に変数や引数に代入したり返り値として返したりできる性質を，Scala では「関数が第一級の値（First Class Object）である」と表現する．  関数のカリー化  関数のカリー化とは，引数が複数個ある関数を，引数が1つの関数のチェインで表現すること． 無名関数を定義する構文をネストするだけで，カリー化が行える．  val add = (x: Int, y: Int) =\u0026gt; x + y val addCurried = (x: Int) =\u0026gt; ((y: Int) =\u0026gt; x + y) // カリー化  add(10, 20) add(10)(20) メソッドと関数は違うもの  メソッド: def で始まる構文で定義されたものであり，第一級の値でない． 関数: 第一級の値である． つまり，Scala には，メソッドを引数に取ったり，メソッドを返したりする関数やメソッドが変数に入ったものは存在しないということ．  高階関数  高階関数とは，関数を引数に取ったり，関数を返したりするメソッドや関数のこと．  "});index.add({'id':7,'href':'/docs/','title':"Docs",'content':""});})();